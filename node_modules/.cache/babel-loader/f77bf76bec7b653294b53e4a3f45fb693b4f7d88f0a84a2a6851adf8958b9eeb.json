{"ast":null,"code":"import { ensureIndex, getFullGeometryRange, getRootIndexRanges, getTriCount, hasGroupGaps } from './geometryUtils.js';\nimport { getBounds, getCentroidBounds, computeTriangleBounds } from './computeBoundsUtils.js';\nimport { getOptimalSplit } from './splitUtils.js';\nimport { MeshBVHNode } from '../MeshBVHNode.js';\nimport { BYTES_PER_NODE, IS_LEAFNODE_FLAG } from '../Constants.js';\nimport { partition } from './sortUtils.generated.js';\nimport { partition_indirect } from './sortUtils_indirect.generated.js';\nfunction generateIndirectBuffer(geometry, useSharedArrayBuffer) {\n  const triCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n  const useUint32 = triCount > 2 ** 16;\n  const byteCount = useUint32 ? 4 : 2;\n  const buffer = useSharedArrayBuffer ? new SharedArrayBuffer(triCount * byteCount) : new ArrayBuffer(triCount * byteCount);\n  const indirectBuffer = useUint32 ? new Uint32Array(buffer) : new Uint16Array(buffer);\n  for (let i = 0, l = indirectBuffer.length; i < l; i++) {\n    indirectBuffer[i] = i;\n  }\n  return indirectBuffer;\n}\nfunction buildTree(bvh, options) {\n  // Compute the full bounds of the geometry at the same time as triangle bounds because\n  // we'll need it for the root bounds in the case with no groups and it should be fast here.\n  // We can't use the geometry bounding box if it's available because it may be out of date.\n  const geometry = bvh.geometry;\n  const indexArray = geometry.index ? geometry.index.array : null;\n  const maxDepth = options.maxDepth;\n  const verbose = options.verbose;\n  const maxLeafTris = options.maxLeafTris;\n  const strategy = options.strategy;\n  const onProgress = options.onProgress;\n  const totalTriangles = getTriCount(geometry);\n  const indirectBuffer = bvh._indirectBuffer;\n  let reachedMaxDepth = false;\n  const fullBounds = new Float32Array(6);\n  const cacheCentroidBoundingData = new Float32Array(6);\n  const triangleBounds = computeTriangleBounds(geometry, fullBounds);\n  const partionFunc = options.indirect ? partition_indirect : partition;\n  const roots = [];\n  const ranges = options.indirect ? getFullGeometryRange(geometry) : getRootIndexRanges(geometry);\n  if (ranges.length === 1) {\n    const range = ranges[0];\n    const root = new MeshBVHNode();\n    root.boundingData = fullBounds;\n    getCentroidBounds(triangleBounds, range.offset, range.count, cacheCentroidBoundingData);\n    splitNode(root, range.offset, range.count, cacheCentroidBoundingData);\n    roots.push(root);\n  } else {\n    for (let range of ranges) {\n      const root = new MeshBVHNode();\n      root.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData);\n      splitNode(root, range.offset, range.count, cacheCentroidBoundingData);\n      roots.push(root);\n    }\n  }\n  return roots;\n  function triggerProgress(trianglesProcessed) {\n    if (onProgress) {\n      onProgress(trianglesProcessed / totalTriangles);\n    }\n  }\n\n  // either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n  // recording the offset and count of its triangles and writing them into the reordered geometry index.\n  function splitNode(node, offset, count) {\n    let centroidBoundingData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let depth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    if (!reachedMaxDepth && depth >= maxDepth) {\n      reachedMaxDepth = true;\n      if (verbose) {\n        console.warn(`MeshBVH: Max depth of ${maxDepth} reached when generating BVH. Consider increasing maxDepth.`);\n        console.warn(geometry);\n      }\n    }\n\n    // early out if we've met our capacity\n    if (count <= maxLeafTris || depth >= maxDepth) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n      return node;\n    }\n\n    // Find where to split the volume\n    const split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);\n    if (split.axis === -1) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n      return node;\n    }\n    const splitOffset = partionFunc(indirectBuffer, indexArray, triangleBounds, offset, count, split);\n\n    // create the two new child nodes\n    if (splitOffset === offset || splitOffset === offset + count) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n    } else {\n      node.splitAxis = split.axis;\n\n      // create the left child and compute its bounding box\n      const left = new MeshBVHNode();\n      const lstart = offset;\n      const lcount = splitOffset - offset;\n      node.left = left;\n      left.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);\n      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);\n\n      // repeat for right\n      const right = new MeshBVHNode();\n      const rstart = splitOffset;\n      const rcount = count - lcount;\n      node.right = right;\n      right.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);\n      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);\n    }\n    return node;\n  }\n}\nexport function buildPackedTree(bvh, options) {\n  const geometry = bvh.geometry;\n  if (options.indirect) {\n    bvh._indirectBuffer = generateIndirectBuffer(geometry, options.useSharedArrayBuffer);\n    if (hasGroupGaps(geometry) && !options.verbose) {\n      console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the \"indirect\" option. ' + 'BVH may incorrectly report intersections on unrendered portions of the geometry.');\n    }\n  }\n  if (!bvh._indirectBuffer) {\n    ensureIndex(geometry, options);\n  }\n\n  // boundingData  \t\t\t\t: 6 float32\n  // right / offset \t\t\t\t: 1 uint32\n  // splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n  const roots = buildTree(bvh, options);\n  let float32Array;\n  let uint32Array;\n  let uint16Array;\n  const packedRoots = [];\n  const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n  for (let i = 0; i < roots.length; i++) {\n    const root = roots[i];\n    let nodeCount = countNodes(root);\n    const buffer = new BufferConstructor(BYTES_PER_NODE * nodeCount);\n    float32Array = new Float32Array(buffer);\n    uint32Array = new Uint32Array(buffer);\n    uint16Array = new Uint16Array(buffer);\n    populateBuffer(0, root);\n    packedRoots.push(buffer);\n  }\n  bvh._roots = packedRoots;\n  return;\n  function countNodes(node) {\n    if (node.count) {\n      return 1;\n    } else {\n      return 1 + countNodes(node.left) + countNodes(node.right);\n    }\n  }\n  function populateBuffer(byteOffset, node) {\n    const stride4Offset = byteOffset / 4;\n    const stride2Offset = byteOffset / 2;\n    const isLeaf = !!node.count;\n    const boundingData = node.boundingData;\n    for (let i = 0; i < 6; i++) {\n      float32Array[stride4Offset + i] = boundingData[i];\n    }\n    if (isLeaf) {\n      const offset = node.offset;\n      const count = node.count;\n      uint32Array[stride4Offset + 6] = offset;\n      uint16Array[stride2Offset + 14] = count;\n      uint16Array[stride2Offset + 15] = IS_LEAFNODE_FLAG;\n      return byteOffset + BYTES_PER_NODE;\n    } else {\n      const left = node.left;\n      const right = node.right;\n      const splitAxis = node.splitAxis;\n      let nextUnusedPointer;\n      nextUnusedPointer = populateBuffer(byteOffset + BYTES_PER_NODE, left);\n      if (nextUnusedPointer / 4 > Math.pow(2, 32)) {\n        throw new Error('MeshBVH: Cannot store child pointer greater than 32 bits.');\n      }\n      uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;\n      nextUnusedPointer = populateBuffer(nextUnusedPointer, right);\n      uint32Array[stride4Offset + 7] = splitAxis;\n      return nextUnusedPointer;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}